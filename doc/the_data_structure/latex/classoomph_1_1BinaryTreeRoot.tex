\hypertarget{classoomph_1_1BinaryTreeRoot}{}\doxysection{oomph\+::Binary\+Tree\+Root Class Reference}
\label{classoomph_1_1BinaryTreeRoot}\index{oomph::BinaryTreeRoot@{oomph::BinaryTreeRoot}}


\mbox{\hyperlink{classoomph_1_1BinaryTreeRoot}{Binary\+Tree\+Root}} is a \mbox{\hyperlink{classoomph_1_1BinaryTree}{Binary\+Tree}} that forms the root of a (recursive) binary tree. The \char`\"{}root node\char`\"{} is special as it holds additional information about its neighbours.  




{\ttfamily \#include $<$binary\+\_\+tree.\+h$>$}

Inheritance diagram for oomph\+::Binary\+Tree\+Root\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classoomph_1_1BinaryTreeRoot}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1BinaryTreeRoot_a0041d849b67407699770118eaa06b52a}{Binary\+Tree\+Root}} (\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Constructor for the (empty) root binary tree\+: Pass pointer to associated object, a \mbox{\hyperlink{classoomph_1_1RefineableQElement_3_011_01_4}{Refineable\+QElement$<$1$>$}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1BinaryTreeRoot_a7e218bf7162d8d1a49569d89eda8091b}{Binary\+Tree\+Root}} (const \mbox{\hyperlink{classoomph_1_1BinaryTreeRoot}{Binary\+Tree\+Root}} \&dummy)=delete
\begin{DoxyCompactList}\small\item\em Broken copy constructor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1BinaryTreeRoot_a2e6227a8c4adc5bee556f3ab8630bcb2}{operator=}} (const \mbox{\hyperlink{classoomph_1_1BinaryTreeRoot}{Binary\+Tree\+Root}} \&)=delete
\begin{DoxyCompactList}\small\item\em Broken assignment operator. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classoomph_1_1BinaryTreeRoot_a2068dd13b3a8636bbcde996e39dc7d1c}{direction\+\_\+of\+\_\+neighbour}} (\mbox{\hyperlink{classoomph_1_1BinaryTreeRoot}{Binary\+Tree\+Root}} $\ast$binary\+\_\+tree\+\_\+root\+\_\+pt)
\begin{DoxyCompactList}\small\item\em If binary\+\_\+tree\+\_\+root\+\_\+pt is a neighbour, return the direction (L/R) in which it is found, otherwise return OMEGA. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions inherited from \mbox{\hyperlink{classoomph_1_1BinaryTree}{oomph\+::\+Binary\+Tree}}}
\begin{DoxyCompactItemize}
\item 
virtual \mbox{\hyperlink{classoomph_1_1BinaryTree_a782282825e91454e43d79a847cedecf5}{$\sim$\+Binary\+Tree}} ()
\begin{DoxyCompactList}\small\item\em Destructor. Note\+: Deleting a binary tree also deletes the objects associated with all non-\/leaf nodes! \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1BinaryTree_a975c16fbb78805368147355ea8dc3155}{Binary\+Tree}} (const \mbox{\hyperlink{classoomph_1_1BinaryTree}{Binary\+Tree}} \&dummy)=delete
\begin{DoxyCompactList}\small\item\em Broken copy constructor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1BinaryTree_a9664459412b745b8b0a941d4565c1c34}{operator=}} (const \mbox{\hyperlink{classoomph_1_1BinaryTree}{Binary\+Tree}} \&)=delete
\begin{DoxyCompactList}\small\item\em Broken assignment operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ \mbox{\hyperlink{classoomph_1_1BinaryTree_a9a7e1fc260782f884cff07e7eb9db28f}{construct\+\_\+son}} (\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_aa2918f6d84795c9f366adb178e287843}{father\+\_\+pt}}, const int \&\mbox{\hyperlink{classoomph_1_1Tree_a7537f8fe7c896d2220eb2da03567b34d}{son\+\_\+type}})
\begin{DoxyCompactList}\small\item\em Overload the function construct\+\_\+son to ensure that the son is a specific \mbox{\hyperlink{classoomph_1_1BinaryTree}{Binary\+Tree}} and not a general \mbox{\hyperlink{classoomph_1_1Tree}{Tree}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1BinaryTree}{Binary\+Tree}} $\ast$ \mbox{\hyperlink{classoomph_1_1BinaryTree_aba768160bad3531d0f62033788619f56}{gteq\+\_\+edge\+\_\+neighbour}} (const int \&direction, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&s\+\_\+in\+\_\+neighbour, int \&edge, int \&diff\+\_\+level, bool \&in\+\_\+neighbouring\+\_\+tree) const
\begin{DoxyCompactList}\small\item\em Return pointer to greater or equal-\/sized edge neighbour in specified {\ttfamily direction}; also provide info regarding the relative size of the neighbour\+: \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1BinaryTree_ac8052fae786bd4aad0a7334d04b59328}{self\+\_\+test}} ()
\begin{DoxyCompactList}\small\item\em Self-\/test\+: Check all neighbours. Return success (0) if the maximum distance between corresponding points in the neighbours is less than the tolerance specified in the static value \mbox{\hyperlink{classoomph_1_1Tree_aef9abebc166fa3bf81ecb59ec0d5d6b2}{Binary\+Tree\+::\+Max\+\_\+neighbour\+\_\+finding\+\_\+tolerance}}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions inherited from \mbox{\hyperlink{classoomph_1_1Tree}{oomph\+::\+Tree}}}
\begin{DoxyCompactItemize}
\item 
virtual \mbox{\hyperlink{classoomph_1_1Tree_ace0b4169cf94a040c280af8e14f6a283}{$\sim$\+Tree}} ()
\begin{DoxyCompactList}\small\item\em Destructor. Note\+: Deleting a tree also deletes the objects associated with its non-\/leave nodes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Tree_a50dce113a40c6ac422353ab149b2d4eb}{Tree}} (const \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} \&dummy)=delete
\begin{DoxyCompactList}\small\item\em Broken copy constructor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_a6bce57d784f256d8d7b8d14432a7d77a}{operator=}} (const \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} \&)=delete
\begin{DoxyCompactList}\small\item\em Broken assignment operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$ \mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return the pointer to the object (\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}}) represented by the tree. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_a96a95bd9942e906fde87194845a1868c}{flush\+\_\+object}} ()
\begin{DoxyCompactList}\small\item\em Flush the object represented by the tree. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ \mbox{\hyperlink{classoomph_1_1Tree_a9851a9dd06212b6891ce9a8bc832d4cf}{son\+\_\+pt}} (const int \&son\+\_\+index) const
\begin{DoxyCompactList}\small\item\em Return pointer to the son for a given index. Note that to aid code readability specific enums have been defined for specific trees. However, these are simply aliases for ints and the general interface can be implemented once, here. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_ab7026d14ead1a8d91ce417dfd0cd9478}{set\+\_\+son\+\_\+pt}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ $>$ \&\mbox{\hyperlink{classoomph_1_1Tree_a9851a9dd06212b6891ce9a8bc832d4cf}{son\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Set vector of pointers to sons, indexed by the appropriate enum that identies son types. (To aid code readability specific enums have been defined for specific trees. However, these are simply aliases for ints and the general interface can be implemented once, here). \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Tree_a31e4123b40f6fb52d180a154c9123e85}{nsons}} () const
\begin{DoxyCompactList}\small\item\em Return number of sons (zero if it\textquotesingle{}s a leaf node) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_a34df656d2f298dbbdf60e7890a3dff2f}{flush\+\_\+sons}} ()
\begin{DoxyCompactList}\small\item\em Flush the sons. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TreeRoot}{Tree\+Root}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Tree_a33b9926754cddfaafd9869af3fe266e7}{root\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return pointer to root of the tree. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TreeRoot}{Tree\+Root}} $\ast$ \mbox{\hyperlink{classoomph_1_1Tree_aa4a6a5242b5969cfd8d7d37da68f3495}{root\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return pointer to root of the tree (const version) \end{DoxyCompactList}\item 
{\footnotesize template$<$class ELEMENT $>$ }\\void \mbox{\hyperlink{classoomph_1_1Tree_a975ccfd63ffa14a04f14a37b3d2ff931}{split\+\_\+if\+\_\+required}} ()
\begin{DoxyCompactList}\small\item\em If required, split the leaf and create its sons -- criterion\+: bool \mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt()}}-\/\texorpdfstring{$>$}{>} to\+\_\+be\+\_\+refined() = true. \end{DoxyCompactList}\item 
{\footnotesize template$<$class ELEMENT $>$ }\\void \mbox{\hyperlink{classoomph_1_1Tree_a6502324233a86eeeadba7f46505656af}{p\+\_\+refine\+\_\+if\+\_\+required}} (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&mesh\+\_\+pt)
\begin{DoxyCompactList}\small\item\em If required, p-\/refine the leaf -- criterion\+: bool \mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt()}}-\/\texorpdfstring{$>$}{>} to\+\_\+be\+\_\+p\+\_\+refined() = true or bool \mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt()}}-\/\texorpdfstring{$>$}{>} to\+\_\+be\+\_\+p\+\_\+unrefined() = true. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_af4f977931ece6b719a9e616037bb2481}{merge\+\_\+sons\+\_\+if\+\_\+required}} (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&mesh\+\_\+pt)
\begin{DoxyCompactList}\small\item\em If required, merge the four sons for unrefinement -- criterion\+: bool \mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt()}}-\/\texorpdfstring{$>$}{>} sons\+\_\+to\+\_\+be\+\_\+unrefined() = true. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_aea17489589a1872db51f2b142da4c1fb}{deactivate\+\_\+object}} ()
\begin{DoxyCompactList}\small\item\em Call the \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}}\textquotesingle{}s deactivate\+\_\+element() function. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ \mbox{\hyperlink{classoomph_1_1Tree_aca2fa14194f424583fd6425a8c4bbff2}{construct\+\_\+son}} (\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_aa2918f6d84795c9f366adb178e287843}{father\+\_\+pt}}, const int \&\mbox{\hyperlink{classoomph_1_1Tree_a7537f8fe7c896d2220eb2da03567b34d}{son\+\_\+type}})=0
\begin{DoxyCompactList}\small\item\em A function that constructs a specific type of tree. This MUST be overloaded for each specific tree type. The use of such a function allows the generic implementation of \mbox{\hyperlink{classoomph_1_1Tree_a975ccfd63ffa14a04f14a37b3d2ff931}{split\+\_\+if\+\_\+required()}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_a3caab39c8bee6fb65bbafed523aa6d3d}{traverse\+\_\+all}} (\mbox{\hyperlink{classoomph_1_1Tree_a6b8ef236d41f52c92973682ca83679d5}{Tree\+::\+Void\+Member\+Fct\+Pt}} member\+\_\+function)
\begin{DoxyCompactList}\small\item\em Traverse the tree and execute void \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} member function member\+\_\+function() at all its \char`\"{}nodes\char`\"{}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_af5c67186ca9c87eef9ce7eaa0af41057}{traverse\+\_\+all}} (\mbox{\hyperlink{classoomph_1_1Tree_a498ffc10556f4335e831a06fc885a27a}{Tree\+::\+Void\+Mesh\+Pt\+Argument\+Member\+Fct\+Pt}} member\+\_\+function, \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&mesh\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Traverse the tree and excute void \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} member function that takes a pointer to a mesh as an argument. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_aef175445b09edb47624c4b88c6d548bc}{traverse\+\_\+all\+\_\+but\+\_\+leaves}} (\mbox{\hyperlink{classoomph_1_1Tree_a6b8ef236d41f52c92973682ca83679d5}{Tree\+::\+Void\+Member\+Fct\+Pt}} member\+\_\+function)
\begin{DoxyCompactList}\small\item\em Traverse the tree and execute void \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} member function member\+\_\+function() at all its \char`\"{}nodes\char`\"{} aparat from the leaves. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_a22e0e3695dd8986e439927b7657ff741}{traverse\+\_\+leaves}} (\mbox{\hyperlink{classoomph_1_1Tree_a6b8ef236d41f52c92973682ca83679d5}{Tree\+::\+Void\+Member\+Fct\+Pt}} member\+\_\+function)
\begin{DoxyCompactList}\small\item\em Traverse the tree and execute void \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} member function member\+\_\+function() only at its leaves. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_a914e74ef473b7e82299ea9337d37830d}{traverse\+\_\+leaves}} (\mbox{\hyperlink{classoomph_1_1Tree_a498ffc10556f4335e831a06fc885a27a}{Tree\+::\+Void\+Mesh\+Pt\+Argument\+Member\+Fct\+Pt}} member\+\_\+function, \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&mesh\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Traverse the tree and execute void \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} member function that takes a pointer to a mesh as an argument only at its leaves. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_accfbeb9178ce92a8a51e3a15293a86d1}{stick\+\_\+leaves\+\_\+into\+\_\+vector}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ $>$ \&)
\begin{DoxyCompactList}\small\item\em Traverse tree and stick pointers to leaf \char`\"{}nodes\char`\"{} (only) into \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_a2c84b4e4700a825ef0a6ca533b9ae895}{stick\+\_\+all\+\_\+tree\+\_\+nodes\+\_\+into\+\_\+vector}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ $>$ \&)
\begin{DoxyCompactList}\small\item\em Traverse and stick pointers to all \char`\"{}nodes\char`\"{} into \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classoomph_1_1Tree_a7537f8fe7c896d2220eb2da03567b34d}{son\+\_\+type}} () const
\begin{DoxyCompactList}\small\item\em Return son type. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Tree_a72000456c76880e3f78f8f8fb43d49d8}{is\+\_\+leaf}} ()
\begin{DoxyCompactList}\small\item\em Return true if the tree is a leaf node. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ \mbox{\hyperlink{classoomph_1_1Tree_aa2918f6d84795c9f366adb178e287843}{father\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return pointer to father\+: NULL if it\textquotesingle{}s a root node. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Tree_ac0cf27d3116db0f8d2f18b3faf09ec15}{set\+\_\+father\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_aa2918f6d84795c9f366adb178e287843}{father\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Set the father. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Tree_ab3eba84432fcc595684ac7eb8331b8ee}{level}} () const
\begin{DoxyCompactList}\small\item\em Return the level of the \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} (root=0) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions inherited from \mbox{\hyperlink{classoomph_1_1TreeRoot}{oomph\+::\+Tree\+Root}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1TreeRoot_a9220f966655424676f4a5710b016c23d}{Tree\+Root}} (\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Constructor for the (empty) root tree. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TreeRoot_a7db9e51a9aa23d8894ad0fc573853d05}{Tree\+Root}} (const \mbox{\hyperlink{classoomph_1_1TreeRoot}{Tree\+Root}} \&dummy)=delete
\begin{DoxyCompactList}\small\item\em Broken copy constructor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1TreeRoot_a1c486b91b11d6524a23f4ab8298f696b}{operator=}} (const \mbox{\hyperlink{classoomph_1_1TreeRoot}{Tree\+Root}} \&)=delete
\begin{DoxyCompactList}\small\item\em Broken assignment operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TreeRoot}{Tree\+Root}} $\ast$\& \mbox{\hyperlink{classoomph_1_1TreeRoot_ae25383c6dd2ab2def3dc98bb5e279d58}{neighbour\+\_\+pt}} (const int \&direction)
\begin{DoxyCompactList}\small\item\em Return the pointer to the neighbouring Tree\+Roots in specified direction. Returns NULL if there\textquotesingle{}s no neighbour in this direction. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1TreeRoot_a7be347e54e34f924c008c302f5146064}{is\+\_\+neighbour\+\_\+periodic}} (const int \&direction)
\begin{DoxyCompactList}\small\item\em Return whether the neighbour in the particular direction is periodic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1TreeRoot_ad4a2c51b2b42261bd8dde67ca32c594c}{set\+\_\+neighbour\+\_\+periodic}} (const int \&direction)
\begin{DoxyCompactList}\small\item\em Set the neighbour in particular direction to be periodic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1TreeRoot_a9e20f4787d7b34d5f4462dea63fd0204}{set\+\_\+neighbour\+\_\+nonperiodic}} (const int \&direction)
\begin{DoxyCompactList}\small\item\em Set the neighbour in particular direction to be nonperiodic. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1TreeRoot_a81be1a835829a48f7f443dcc85f369b9}{nneighbour}} ()
\begin{DoxyCompactList}\small\item\em Return the number of neighbours. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}
\doxysubsubsection*{Public Types inherited from \mbox{\hyperlink{classoomph_1_1Tree}{oomph\+::\+Tree}}}
\begin{DoxyCompactItemize}
\item 
typedef void(Tree\+::$\ast$ \mbox{\hyperlink{classoomph_1_1Tree_a6b8ef236d41f52c92973682ca83679d5}{Void\+Member\+Fct\+Pt}}) ()
\begin{DoxyCompactList}\small\item\em Function pointer to argument-\/free void \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} member function. \end{DoxyCompactList}\item 
typedef void(Tree\+::$\ast$ \mbox{\hyperlink{classoomph_1_1Tree_a498ffc10556f4335e831a06fc885a27a}{Void\+Mesh\+Pt\+Argument\+Member\+Fct\+Pt}}) (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&mesh\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Function pointer to a void \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} member function that takes a pointer to a mesh as its argument. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions inherited from \mbox{\hyperlink{classoomph_1_1BinaryTree}{oomph\+::\+Binary\+Tree}}}
\begin{DoxyCompactItemize}
\item 
static void \mbox{\hyperlink{classoomph_1_1BinaryTree_a46528d3d7749ee316f193f28b5abd8fb}{setup\+\_\+static\+\_\+data}} ()
\begin{DoxyCompactList}\small\item\em Set up the static data, reflection schemes, etc. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classoomph_1_1BinaryTree_a49791c16aedc51ecd542ce65507c68c6}{doc\+\_\+neighbours}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ $>$ forest\+\_\+nodes\+\_\+pt, std\+::ofstream \&neighbours\+\_\+file, std\+::ofstream \&neighbours\+\_\+txt\+\_\+file, double \&max\+\_\+error)
\begin{DoxyCompactList}\small\item\em Doc/check all neighbours of binary tree (nodes) contained in the \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} forest\+\_\+node\+\_\+pt. Output into neighbours\+\_\+file which can be viewed from tecplot with Binary\+Tree\+Neighbours.\+mcr. Neighbour info and errors are displayed on neighbours\+\_\+txt\+\_\+file. Finally, compute the maximum error between vertices when viewed from the neighbouring element. If the two filestreams are closed, output is suppressed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions inherited from \mbox{\hyperlink{classoomph_1_1Tree}{oomph\+::\+Tree}}}
\begin{DoxyCompactItemize}
\item 
static double \& \mbox{\hyperlink{classoomph_1_1Tree_a939e2d66696d9d59b47cea8c8d05957c}{max\+\_\+neighbour\+\_\+finding\+\_\+tolerance}} ()
\begin{DoxyCompactList}\small\item\em Max. allowed discrepancy in neighbour finding routine (distance between points when identified from two neighbouring elements) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes inherited from \mbox{\hyperlink{classoomph_1_1BinaryTree}{oomph\+::\+Binary\+Tree}}}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::string $>$ \mbox{\hyperlink{classoomph_1_1BinaryTree_a24331ca02be2713a58833da84ed02f9b}{Direct\+\_\+string}}
\begin{DoxyCompactList}\small\item\em Translate (enumerated) directions into strings. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes inherited from \mbox{\hyperlink{classoomph_1_1Tree}{oomph\+::\+Tree}}}
\begin{DoxyCompactItemize}
\item 
static const int \mbox{\hyperlink{classoomph_1_1Tree_a9e532196340dcd859ff8207eea2ddbbc}{OMEGA}} = 26
\begin{DoxyCompactList}\small\item\em Default value for an unassigned neighbour. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classoomph_1_1BinaryTree}{oomph\+::\+Binary\+Tree}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1BinaryTree_a3ad7c1ba04813b506e2d70a82b45df9c}{Binary\+Tree}} ()
\begin{DoxyCompactList}\small\item\em Default constructor (empty and broken) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1BinaryTree_a17856140e51fd48c3441d0b48d854152}{Binary\+Tree}} (\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Default constructor for empty (root) tree\+: no father, no sons; just pass a pointer to its object. Protected because Binary\+Trees can only be created internally, during the split operation. Only Binary\+Tree\+Roots can be created externally. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1BinaryTree_a1e1f22c07b554709b8aa76356d9f005f}{Binary\+Tree}} (\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_aa2918f6d84795c9f366adb178e287843}{father\+\_\+pt}}, const int \&\mbox{\hyperlink{classoomph_1_1Tree_a7537f8fe7c896d2220eb2da03567b34d}{son\+\_\+type}})
\begin{DoxyCompactList}\small\item\em Constructor for tree that has a father\+: Pass it the pointer to its object, the pointer to its father and tell it what type of son (L/R) it is. Protected because Binary\+Trees can only be created internally, during the split operation. Only Binary\+Tree\+Roots can be created externally. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classoomph_1_1Tree}{oomph\+::\+Tree}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1Tree_ada92f1aa44ee6ef5b52ec5ad0af00359}{Tree}} ()
\begin{DoxyCompactList}\small\item\em Default constructor (empty and broken) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Tree_a6e78c3a130add917de182ab5f1674531}{Tree}} (\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Default constructor for empty (root) tree\+: no father, no sons; just pass a pointer to its object Protected because Trees can only be created internally, during the split operation. Only Tree\+Roots can be created externally. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Tree_a9d611dde1f429500330f28e56ee71883}{Tree}} (\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_a7d630dad19ef861ab6a5f37ad6ea67f4}{object\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Tree_aa2918f6d84795c9f366adb178e287843}{father\+\_\+pt}}, const int \&\mbox{\hyperlink{classoomph_1_1Tree_a7537f8fe7c896d2220eb2da03567b34d}{son\+\_\+type}})
\begin{DoxyCompactList}\small\item\em Constructor for tree that has a father\+: Pass it the pointer to its object, the pointer to its father and tell it what type of son it is. Protected because Trees can only be created internally, during the split operation. Only Tree\+Roots can be created externally. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes inherited from \mbox{\hyperlink{classoomph_1_1Tree}{oomph\+::\+Tree}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1TreeRoot}{Tree\+Root}} $\ast$ \mbox{\hyperlink{classoomph_1_1Tree_a61782afd668561ad7ab324f658ffeb6a}{Root\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the root of the tree. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ \mbox{\hyperlink{classoomph_1_1Tree_a001ce5515a3d76cdad248695e149504b}{Father\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the Father of the \mbox{\hyperlink{classoomph_1_1Tree}{Tree}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} $\ast$ $>$ \mbox{\hyperlink{classoomph_1_1Tree_ac6b9069f345b296654421604c5569af6}{Son\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to the sons of the \mbox{\hyperlink{classoomph_1_1Tree}{Tree}}. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classoomph_1_1Tree_a9ac30decb7a63027906880620f8b98ee}{Level}}
\begin{DoxyCompactList}\small\item\em Level of the \mbox{\hyperlink{classoomph_1_1Tree}{Tree}} (level 0 = root) \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classoomph_1_1Tree_a83fe7895af25c9f60062c081fc51967c}{Son\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Son type (e.\+g. SW/\+SE/\+NW/\+NE in a quadtree) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$ \mbox{\hyperlink{classoomph_1_1Tree_a61ee20b575da510512d0e108cf7b06c6}{Object\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the object represented by the tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes inherited from \mbox{\hyperlink{classoomph_1_1TreeRoot}{oomph\+::\+Tree\+Root}}}
\begin{DoxyCompactItemize}
\item 
std\+::map$<$ int, \mbox{\hyperlink{classoomph_1_1TreeRoot}{Tree\+Root}} $\ast$ $>$ \mbox{\hyperlink{classoomph_1_1TreeRoot_a8923854080ee44a2d1be477000309b13}{Neighbour\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Map of pointers to the neighbouring Tree\+Roots\+: Neighbour\+\_\+pt\mbox{[}direction\mbox{]} returns the pointer to the \mbox{\hyperlink{classoomph_1_1TreeRoot}{Tree\+Root}}\textquotesingle{}s neighbour in the (enumerated) direction. Returns NULL if there\textquotesingle{}s no neighbour in this direction. \end{DoxyCompactList}\item 
std\+::map$<$ int, bool $>$ \mbox{\hyperlink{classoomph_1_1TreeRoot_a067533f9b739e6c185ce776ea0c98e88}{Neighbour\+\_\+periodic}}
\begin{DoxyCompactList}\small\item\em Map of booleans used for periodic boundaries\+: Neighbour\+\_\+periodic\+\_\+direction\mbox{[}directon\mbox{]} returns true if the neighbour in that direction is actually a periodic neighbour --- shared data values, but independent position. The default return of the map is false. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Protected Attributes inherited from \mbox{\hyperlink{classoomph_1_1BinaryTree}{oomph\+::\+Binary\+Tree}}}
\begin{DoxyCompactItemize}
\item 
static bool \mbox{\hyperlink{classoomph_1_1BinaryTree_a5890507c23970c4e2604fb65a546b9b4}{Static\+\_\+data\+\_\+has\+\_\+been\+\_\+setup}} = false
\begin{DoxyCompactList}\small\item\em Boolean indicating that static member data has been setup. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Protected Attributes inherited from \mbox{\hyperlink{classoomph_1_1Tree}{oomph\+::\+Tree}}}
\begin{DoxyCompactItemize}
\item 
static double \mbox{\hyperlink{classoomph_1_1Tree_aef9abebc166fa3bf81ecb59ec0d5d6b2}{Max\+\_\+neighbour\+\_\+finding\+\_\+tolerance}} = 1.\+0e-\/14
\begin{DoxyCompactList}\small\item\em Max. allowed discrepancy in neighbour finding routine (distance between points when identified from two neighbouring elements) \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{classoomph_1_1BinaryTreeRoot}{Binary\+Tree\+Root}} is a \mbox{\hyperlink{classoomph_1_1BinaryTree}{Binary\+Tree}} that forms the root of a (recursive) binary tree. The \char`\"{}root node\char`\"{} is special as it holds additional information about its neighbours. 

Definition at line \mbox{\hyperlink{binary__tree_8h_source_l00230}{230}} of file \mbox{\hyperlink{binary__tree_8h_source}{binary\+\_\+tree.\+h}}.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classoomph_1_1BinaryTreeRoot_a0041d849b67407699770118eaa06b52a}\label{classoomph_1_1BinaryTreeRoot_a0041d849b67407699770118eaa06b52a}} 
\index{oomph::BinaryTreeRoot@{oomph::BinaryTreeRoot}!BinaryTreeRoot@{BinaryTreeRoot}}
\index{BinaryTreeRoot@{BinaryTreeRoot}!oomph::BinaryTreeRoot@{oomph::BinaryTreeRoot}}
\doxysubsubsection{\texorpdfstring{BinaryTreeRoot()}{BinaryTreeRoot()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily oomph\+::\+Binary\+Tree\+Root\+::\+Binary\+Tree\+Root (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$const \&}]{object\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructor for the (empty) root binary tree\+: Pass pointer to associated object, a \mbox{\hyperlink{classoomph_1_1RefineableQElement_3_011_01_4}{Refineable\+QElement$<$1$>$}}. 



Definition at line \mbox{\hyperlink{binary__tree_8h_source_l00235}{235}} of file \mbox{\hyperlink{binary__tree_8h_source}{binary\+\_\+tree.\+h}}.



References \mbox{\hyperlink{binary__tree_8h_source_l00193}{oomph\+::\+Binary\+Tree\+::\+Static\+\_\+data\+\_\+has\+\_\+been\+\_\+setup}}.

\mbox{\Hypertarget{classoomph_1_1BinaryTreeRoot_a7e218bf7162d8d1a49569d89eda8091b}\label{classoomph_1_1BinaryTreeRoot_a7e218bf7162d8d1a49569d89eda8091b}} 
\index{oomph::BinaryTreeRoot@{oomph::BinaryTreeRoot}!BinaryTreeRoot@{BinaryTreeRoot}}
\index{BinaryTreeRoot@{BinaryTreeRoot}!oomph::BinaryTreeRoot@{oomph::BinaryTreeRoot}}
\doxysubsubsection{\texorpdfstring{BinaryTreeRoot()}{BinaryTreeRoot()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily oomph\+::\+Binary\+Tree\+Root\+::\+Binary\+Tree\+Root (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1BinaryTreeRoot}{Binary\+Tree\+Root}} \&}]{dummy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}



Broken copy constructor. 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classoomph_1_1BinaryTreeRoot_a2068dd13b3a8636bbcde996e39dc7d1c}\label{classoomph_1_1BinaryTreeRoot_a2068dd13b3a8636bbcde996e39dc7d1c}} 
\index{oomph::BinaryTreeRoot@{oomph::BinaryTreeRoot}!direction\_of\_neighbour@{direction\_of\_neighbour}}
\index{direction\_of\_neighbour@{direction\_of\_neighbour}!oomph::BinaryTreeRoot@{oomph::BinaryTreeRoot}}
\doxysubsubsection{\texorpdfstring{direction\_of\_neighbour()}{direction\_of\_neighbour()}}
{\footnotesize\ttfamily int oomph\+::\+Binary\+Tree\+Root\+::direction\+\_\+of\+\_\+neighbour (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1BinaryTreeRoot}{Binary\+Tree\+Root}} $\ast$}]{binary\+\_\+tree\+\_\+root\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



If binary\+\_\+tree\+\_\+root\+\_\+pt is a neighbour, return the direction (L/R) in which it is found, otherwise return OMEGA. 



Definition at line \mbox{\hyperlink{binary__tree_8h_source_l00262}{262}} of file \mbox{\hyperlink{binary__tree_8h_source}{binary\+\_\+tree.\+h}}.



References \mbox{\hyperlink{tree_8h_source_l00330}{oomph\+::\+Tree\+Root\+::\+Neighbour\+\_\+pt}}, and \mbox{\hyperlink{tree_8h_source_l00262}{oomph\+::\+Tree\+::\+OMEGA}}.

\mbox{\Hypertarget{classoomph_1_1BinaryTreeRoot_a2e6227a8c4adc5bee556f3ab8630bcb2}\label{classoomph_1_1BinaryTreeRoot_a2e6227a8c4adc5bee556f3ab8630bcb2}} 
\index{oomph::BinaryTreeRoot@{oomph::BinaryTreeRoot}!operator=@{operator=}}
\index{operator=@{operator=}!oomph::BinaryTreeRoot@{oomph::BinaryTreeRoot}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily void oomph\+::\+Binary\+Tree\+Root\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1BinaryTreeRoot}{Binary\+Tree\+Root}} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}



Broken assignment operator. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{binary__tree_8h}{binary\+\_\+tree.\+h}}\end{DoxyCompactItemize}
